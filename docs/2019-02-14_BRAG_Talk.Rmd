---
title: "Curve Registration"
author: "Anthony Ebert"
date: "14 February 2019"
output: beamer_presentation
bibliography: ../Zotero_link.bib
header-includes:
  - \usepackage{algorithmicx}
  - \usepackage{algpseudocode}
  - \usepackage{algorithm}
---

```{r, include=FALSE}
library(CurveRegistration)
library(dplyr)
library(ggplot2)

true_color <- "black"
#color_scale <- scale_color_manual(values = c("red", "blue", "grey"))
color_scale <- ggthemes::scale_color_wsj()
knitr::opts_chunk$set(echo = FALSE, autodep = TRUE, cache = TRUE, cache.rebuild = FALSE)
```

## Motivation

\begin{figure}
\includegraphics[width=0.5\textwidth]{figure/observation_plot.pdf}
\caption{Passenger flow counts. }
\end{figure}


## Introduction

\begin{figure}
\includegraphics[width=1\textwidth]{figure/Abstract-curve2.png}
\caption{Analysis of growth data, before and after curve registration (Srivastava et al. 2011). }
\end{figure}

## {-}

\begin{figure}
\includegraphics[width=0.8\textwidth]{figure/Abstract-curve.png}
\caption{50 curves before and after registration (Kneip and Ramsay 2008). }
\end{figure}

## Functional data analysis

Functional data analysis (FDA) is the analysis of data generated by curves or functions [@hsing2015theoretical]. Special-cases of functional datasets include longitudinal data and time series. However, the field of FDA is much broader than this [@wang2016functional]. Functional random variables take values in a function space $\mathsf{f} \in \mathcal{F}$ with associated probability measure $p$ (see @delaigle2010defining). In practice, the functional random variables are observed with error on a countable subset of the domain of the function. This is what we refer to as an empirical functional random variable (EFRV). An EFRV $f$ is itself a set of pairs $f_1, f_2, \cdots$ of the form $f_i = (t^f_{i},y^f_{i})$ representing sampling location $t^f_i$ and corresponding function output $y^f_{i}$. Therefore $f$ is of the form $\{ (t^f_{1},y^f_{1}), \cdots , (t^f_{j}, y^f_{j}), \cdots, (t^f_{n}, y^f_{n}) \}$. We append the superscript $f$ to keep track of which sampling points and functional outputs refer to which EFRV.

## {-}

\newcommand{\fsf}{\mathsf{f}}
\newcommand{\gsf}{\mathsf{g}}
\newcommand{\E}{\mathsf{E}}

We standardise the domain of $\mathsf{f^*} \in \mathbb{R}^{[0, T]}$ from $[0,T]$ to $[0,1]$ by setting $\mathsf{f}(t) = \mathsf{f^*}(t \times T)$. The idea of curve registration is to align elements of $\mathcal{F}$ with warping functions $\gamma^{\mathsf{f}}: [0,1] \mapsto [0,1]$, such that elements of the set $\mathcal{G} := \{\mathsf{f} \circ \gamma^{\mathsf{f}} | \mathsf{f} \in \mathcal{F} \}$ have aligned features according to some criteria. We adopt the elastic functions approach of @srivastava2011registration, who align $\fsf$ to another functional random variable $\mathsf{g}$ using the Fisher-Rao metric:
\begin{align}
d_{\text{FR}}(\fsf,\gsf) = \int [ q^{\fsf}(t) - q^{\gsf}(t) ]^2 \text{d} t, 
\end{align} 
where $q^{\fsf}(t) = \text{sign}(\fsf^{\prime}(t)) \times \sqrt{|\fsf^{\prime}(t)|}$. Curve $\fsf$ is aligned to $\gsf$ by defining a warping function $\gamma \in \Gamma$ where $\Gamma = \{\gamma \in [0,1]^{[0, 1]} | \gamma \text{ is invertible and } \gamma(0) = 0 \}$ to minimise $d_{\text{FR}}(\fsf \circ \gamma, \gsf)$. 

## {-}

\newcommand{\fsf}{\mathsf{f}}
\newcommand{\gsf}{\mathsf{g}}
\newcommand{\E}{\mathsf{E}}


Curve $\fsf$ is aligned to $\gsf$ by defining a warping function $\gamma \in \Gamma$ where $\Gamma = \{\gamma \in [0,1]^{[0, 1]} | \gamma \text{ is invertible and } \gamma(0) = 0 \}$ to minimise $d_{\text{FR}}(\fsf \circ \gamma, \gsf)$. One advantage of using $d_{\text{FR}}$ for curve registration is that:
\begin{align*} 
d_{\text{FR}}(\fsf, \gsf) = d_{\text{FR}}(\fsf \circ \gamma, \gsf \circ \gamma), 
\end{align*}
in other words, the Fisher-Rao metric is invariant to shared warpings.

## {-}

\newcommand{\fsf}{\mathsf{f}}
\newcommand{\gsf}{\mathsf{g}}
\newcommand{\E}{\mathsf{E}}

This implies that the discrepancy of amplitudes (amplitude distance) between $\fsf$ and $\gsf$, defined as
\begin{align*}
d_{\text{amp}}(\fsf,\gsf) := \inf_{\gamma \in \Gamma} d_{\text{FR}}(\fsf \circ \gamma, \gsf),
\end{align*}
is symmetric [@srivastava2011registration].

## Approximate Bayesian computation

The FR metric is a dissimilarity, another dissimilarity which we use is the estimator for maximum mean discrepancy ($d_{\text{MMD}}$), developed by @gretton_kernel_2007

The definition of $d_{\text{MMD}}(f,g)$ is as follows:
\begin{align}
d_{\text{MMD}}(f,g) &=  \frac{1}{m^2} \sum_{j=1}^m \sum_{j^{\prime} = 1}^{m} k(f_j, f_{j^{\prime}}) + \nonumber \\
&\quad \quad \frac{1}{n^2} \sum_{j=1}^n \sum_{j^{\prime}  = 1 }^n k(g_j, g_{j^{\prime}}) \nonumber \nonumber \\
&\quad \quad - \frac{2}{mn} \sum_{j=1}^m \sum_{j^{\prime}  = 1 }^n  k(f_j, g_{j^{\prime}}), 
\end{align}
where $m$ is the cardinality of $f$, $n$ is the cardinality of $g$ and $k$ is a kernel function. 

## {-}

A common choice of kernel function is the Gaussian kernel, $k(f_j,g_{j^{\prime}}) = \exp \left[ -0.5 \sqrt{(t^f_j-t^g_{j^{\prime}})^T S^{-1} (y^f_j-y^g_{j^{\prime}})} \right]$, where $S$ is a fixed tuning covariance matrix. @gretton_kernel_2012 showed that $d_{\text{MMD}}$ is equivalent to a kernel-smoothed L2 norm between EFRVs. We can, therefore, use $\hat{\rho}_{\text{MMD}}$ as a dissimilarity on EFRVs rather than probability measures.

## Gaussian peak shift

```{r sGExample, fig.cap="Example of model realisations from the Gaussian peak shift model with $\\sigma_b = 5, \\sigma_{\\phi} = 1$, and $\\sigma_{\\epsilon} = 0.01$. The dotted lines are the $\\mu_u$ values. The distribution of peak shifts is controlled by $\\sigma_b$, the peak widths are controlled by $\\sigma_{\\phi }$, and the noise is controlled by $\\sigma_{\\epsilon}$.", include=TRUE, fig.height=4}

library(CurveRegistration)

set.seed(1)

t <- seq(0, 300, by = 0.5)
alpha = seq(20, 280, by = 20)
theta = c(1, 0.01, 0, 5)


y <- simulator_sGaussian(t, param = theta, alpha = alpha)
z <- simulator_sGaussian(t, param = theta, alpha = alpha)

plot(y, type = "l", lwd = 1, xaxs = "i", yaxs = "i", ylim = c(-0.1, 0.5), col = "blue")
lines(z, col = "red")
abline(v = alpha, lty = 2)
```


## {-}

```{r, sGaussianPost, fig.asp = 0.5, fig.cap="Density plots of posterior samples arising from the replenishment ABC sampler [@drovandi_estimation_2011] for the Gaussian peak shift example. Distances shown include MMD (Maximum mean discrepancy) and FR (Fisher-Rao) in on both registered and unregistered data. Vertical black solid lines represent true values. "}
load("../runs/sGaussian/4/ABC_sG_5.RData")
output_tidy <- tidyr::gather(ABC_sG_5, "parameter", , -registration, -sigma_a, -distance)
output_tidy$parameter <- factor(output_tidy$parameter, labels = c("sigma[epsilon]", "sigma[phi]"))
true_params = c(1, 0.01)
vline_df = data.frame(parameter = c("sigma_phi", "sigma_e"), input = true_params, value = rep(1, 2))
vline_df$parameter <- factor(vline_df$parameter, labels = c("sigma[epsilon]", "sigma[phi]"))
output_tidy <- output_tidy %>%
  mutate(distance = factor(distance)) %>%
  mutate(distance = factor(distance, levels(distance)[c(2,1)])) %>%
  mutate(registration = factor(ifelse(registration, "Registered", "Unregistered"))) %>%
  mutate(registration = factor(registration, levels(registration)[c(2,1)]))
blank_df <- data.frame(parameter = rep(levels(output_tidy$parameter), each = 2), value = c(0, 0.02, 0, 3), registration = rep(output_tidy$registration[1], 4), distance = rep(output_tidy$distance[1], 4))
ggplot(output_tidy) +
  aes(x = value, col = registration, linetype = distance) +
  stat_density(position = "identity", geom = "line") +
  facet_wrap(~parameter, scales = "free", labeller = label_parsed) +
  geom_vline(data = vline_df , mapping = aes(xintercept = input), col = true_color, lty = 1) +
  labs(colour = "Registration status") +
  scale_y_continuous(expand = c(0.02, 0), limits = c(0, NA)) +
  scale_x_continuous(expand = c(0, 0), limits = c(0, NA)) +
  ggthemes::theme_few() +
  ylab(latex2exp::TeX('$\\pi_{ABC} (\\theta | y)$')) +
  theme(axis.ticks.y = element_blank(), axis.text.y = element_blank(), panel.spacing.x = unit(2, "lines"), legend.title = element_blank(), axis.title.x = element_blank() , legend.position = "bottom" , plot.margin = unit(c(0, 2, 0, 0),  "lines")) +
  guides(
    color = guide_legend(order = 0),
    lty = guide_legend(order = 1)
  ) + 
  geom_blank(data = blank_df) +
  color_scale
```

## Passenger processing

\begin{figure}
\includegraphics[width=1\textwidth]{figure/Algorithm.png}
\end{figure}

## {-}

```{r, AirportPost, message=FALSE, fig.cap = "Density plots of posterior samples using the airport loss function (Algorithm 3) for unregistered, registered and corrected types. The solid vertical black line represents the true value."}
load(file = "../runs/airport/2/ABC_airport.RData")

# data file ABC_airport

param_names <- c("mu", "nu", "lambda[f]", "lambda[l]")
true_params <- c(0.02, 0.64, 0.4, 0.5)

vline_df = data.frame(parameter = param_names, input = true_params, value = rep(1, 4))

airport_tidy <- ABC_airport %>% tidyr::gather("parameter", , -registration, -distance, -correction) %>%
  filter(!(!registration & correction)) %>%
  mutate(out = factor(ifelse(!registration, "Unregistered", ifelse(!correction, "Registered", "Corrected")))) %>%
  mutate(out = factor(out, levels(out)[c(3,2,1)]))

# %>% mutate(distance = paste0(distance, ifelse(registration, "", " (reg)")))

airport_tidy$parameter <- factor(airport_tidy$parameter, labels = c("lambda[f]", "lambda[l]", "mu", "nu"))

blank_df <- data.frame(parameter = rep(levels(airport_tidy$parameter), each = 2), value = c(0, 1, 0, 1, 0, 0.05, 0, 1), out = rep(airport_tidy$out[1], 4))

ggplot(airport_tidy %>% filter(distance == "MMD")) +
  aes(x = value, col = out) +
  stat_density(position = "identity", geom = "line") +
  facet_wrap(~parameter, scales = "free", labeller = label_parsed) + 
  scale_y_continuous(expand = c(0.02, 0), limits = c(0, NA)) +
  scale_x_continuous(expand = c(0, 0), limits = c(0, NA)) +
  geom_vline(data = vline_df , mapping = aes(xintercept = input), col = true_color, linetype = 1) +
  ggthemes::theme_few() +
  ylab(latex2exp::TeX('$\\pi_{ABC} (\\theta | y)$')) +
  theme(axis.ticks.y = element_blank(), axis.text.y = element_blank(), panel.spacing.x = unit(2, "lines"), legend.title = element_blank(), axis.title.x = element_blank() , legend.position = "bottom" , plot.margin = unit(c(0, 2, 0, 0),  "lines")) +
  geom_blank(data = blank_df) +
  color_scale
```

---
nocite: | 
  @srivastava2011registration
...
